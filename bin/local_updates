#!/usr/bin/env perl

use strict;
use warnings;
use lib 'lib';

use Jifty;
BEGIN { Jifty->new; }
use Storable qw/thaw/;
use Benchmark qw/timestr/;

use Gearman::Worker;
use TAP::Parser::Aggregator;

my $worker = Gearman::Worker->new(
    job_servers => Jifty->config->app('job_servers'),
);
$worker->register_function(
    check_queue => sub {
        warn "In check_queue";
        my $job = shift;
        my $queued = Smokingit::Model::SmokeResultCollection->new;
        $queued->limit(
            column => "submitted_at",
            operator => "IS",
            value => "NULL",
        );
        my $restarted = 0;
        while (my $smoke = $queued->next) {
            $restarted += $smoke->run_smoke unless $smoke->gearman_status->known;
        }
        return $restarted;
    },
);
$worker->register_function(
    post_results => sub {
        my $job = shift;
        my %result = %{ thaw( $job->arg ) };

        # Properties to extract from the aggregator
        my @props =
            qw/failed
               parse_errors
               passed
               planned
               skipped
               todo
               todo_passed
               wait
               exit/;

        # Aggregator might not exist if we had a configure failure
        my $a = $result{aggregator};
        if ($a) {
            $result{$_} = $a->$_ for @props;
            $result{is_ok}      = not($a->has_problems);
            $result{elapsed}    = $a->elapsed->[0];
            $result{error}      = undef;
        } else {
            # Unset the existing data if there was a fail
            $result{$_} = undef for @props, "is_ok", "elapsed";
        }
        $result{submitted_at} = Jifty::DateTime->now;

        # Find the smoke
        Jifty->handle->begin_transaction;
        my $smokeid = delete $result{smoke_id};
        my $smoke = Smokingit::Model::SmokeResult->new;
        $smoke->load( $smokeid );
        if (not $smoke->id) {
            warn "Invalid smoke ID: $smokeid\n";
            return 0;
        } elsif (not $smoke->gearman_process) {
            warn "Smoke report on $smokeid which wasn't being smoked? (last report at @{[$smoke->submitted_at]})\n";
            return 0;
        }

        # Update with the new data
        for my $key (keys %result) {
            my $method = "set_$key";
            $smoke->$method($result{$key});
        }
        # Mark as no longer smoking
        $smoke->set_gearman_process(undef);

        # And commit all of that
        Jifty->handle->commit;

        warn "Test result for "
            . $smoke->project->name
            ." ". $smoke->commit->short_sha
            ." using ". $smoke->configuration->name
            ." on ". $smoke->from_branch->name
            .": ".($smoke->is_ok ? "OK" : "NOT OK")."\n";

        return 1;
    },
);
$worker->register_function(
    sync_project => sub {
        my $job = shift;
        my $project_name = $job->arg;
        warn "Sync $project_name";

        my $project = Smokingit::Model::Project->new;
        $project->load_by_cols( name => $project_name );
        unless ($project->id) {
            warn "No such project: $project_name\n";
            return 0;
        }

        # Update or clone, as need be
        if (-d $project->repository_path) {
            warn "Updating $project_name\n";
            $project->update_repository;
        } else {
            warn "Cloning $project_name\n";
            system("git", "clone", "--quiet", "--mirror",
                   $project->repository_url,
                   $project->repository_path);
        }

        # Sync up the branches
        Jifty->handle->begin_transaction;
        my $tests = $project->sync_branches;
        Jifty->handle->commit;

        return $tests;
    },
);
$worker->register_function(
    plan_tests => sub {
        my $job = shift;
        my $project_name = $job->arg;

        my $projects = Smokingit::Model::ProjectCollection->new;
        if ($project_name) {
            $projects->limit( column => "name", value => $project_name );
        } else {
            $projects->unlimit;
        }
        return 0 unless $projects->count;

        my $tests = 0;
        while (my $project = $projects->next) {
            Jifty->handle->begin_transaction;
            $tests += $project->schedule_tests;
            Jifty->handle->commit;
        }

        return $tests;
    }
);

$worker->register_function(
    retest => sub {
        my $job = shift;
        my ($sha,$configname,$branchname) = $job->arg =~ /^([0-9a-fA-F]+)(?:\s*\[(.*)\])?(?:\s*,\s*(.*))?/;

        my $commits = Smokingit::Model::CommitCollection->new;
        $commits->limit( column => "sha", operator => "like", value => "$sha%" );
        return 0 unless $commits->count == 1;

        my $commit = $commits->next;
        warn "Retesting @{[$commit->short_sha]}\n";

        my $branch = Smokingit::Model::Branch->new;
        $branch->load_by_cols( project_id => $commit->project->id, name => $branchname )
            if $branchname;
        warn "Invalid branch name $branchname given\n" if $branchname and not $branch->id;

        my $configs = $commit->project->configurations;
        $configs->limit( column => "name", operator => "MATCHES", value => $configname )
            if defined $configname and length $configname;
        warn "Found @{[$configs->count]} configs\n";
        while (my $config = $configs->next) {
            my %lookup = (
                project_id       => $commit->project->id,
                configuration_id => $config->id,
                commit_id        => $commit->id,
            );
            my $smoke = Smokingit::Model::SmokeResult->new;
            $smoke->load_by_cols( %lookup );
            if ($smoke->id) {
                warn "Re-testing @{[$smoke->id]}\n";
                $smoke->set_submitted_at(undef);
                $smoke->set_gearman_process(undef);
                $smoke->run_smoke;
            } elsif ($branch->id) {
                $smoke->create(
                    %lookup,
                    from_branch_id => $branch->id,
                );
                warn "Smoking new @{[$smoke->id]}\n";
                $smoke->run_smoke;
            } else {
                warn "No existing smoke for $sha found, and no branch given\n";
            }
        }
        return 1;
    },
);

$worker->work while 1;
